<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>upload audio</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    
    <script type="module">
      const loading = document.getElementById('loading');
      addEventListener('py:ready', () => loading.close());
      loading.showModal();
  </script>
    <!--pyodide-->

    <py-env>
      - librosa
      - numpy
      - pyloudnorm
      - sklearn
      - pickle
    </py-env>

</head>
<body>
  <dialog id="loading">
    <h1>Loading...</h1>
</dialog>

<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="audioFile" accept="audio/*" required>
  <input type="submit" value="Upload Audio">
</form>

<p>Output</p>
<p id="output"></p>

<py-script> 
  from pyscript import display
  display('hello world') 
</py-script>

<py-script>
  // Load Pyodide
  await loadPyodide();
  // Load NumPy
  const numpyPromise = pyodide.loadPackage("numpy");
  // Wait for NumPy to be loaded
  await numpyPromise;
  // Use NumPy
  const numpy = pyodide.runPython("import numpy; numpy");
  const array = numpy.array([1, 2, 3, 4, 5]);
  console.log(array);

  import numpy as np
  import librosa
  import pyloudnorm as pyln
  from sklearn.preprocessing import StandardScaler
  import pickle
  
  
  class SVM_classifier():
      # Initialize SVM classifier with hyperparameters
      def __init__(self, learning_rate, no_of_iteration, lambda_parameter):
          self.learning_rate = learning_rate
          self.no_of_iteration = no_of_iteration
          self.lambda_parameter = lambda_parameter
          self.w = None
          self.b = None
  
      # Fit the dataset to the SVM classifier
      def fit(self, X, Y):
          self.m, self.n = X.shape
          self.w = np.zeros(self.n)
          self.b = 0
          for i in range(self.no_of_iteration):
              self.update_weights(X, Y)
  
      # Update weights and bias values
      def update_weights(self, X, Y):
          y_label = np.where(Y <= 0, -1, 1)
          for index, x_i in enumerate(X):
              condition = y_label[index] * (np.dot(x_i, self.w) - self.b) >= 1
              if condition:
                  dw = 2 * self.lambda_parameter * self.w
                  db = 0
              else:
                  dw = 2 * self.lambda_parameter * self.w - np.dot(x_i, y_label[index])
                  db = y_label[index]
              self.w -= self.learning_rate * dw
              self.b -= self.learning_rate * db
  
      # Predict the label for a given input value
      def predict(self, X):
          output = np.dot(X, self.w) - self.b
          predicted_labels = np.sign(output)
          return np.where(predicted_labels <= -1, 0, 1)
  
  def extract_features(audio_file):
      y, sr = librosa.load(audio_file, sr=None)
      pitches, _ = librosa.core.piptrack(y=y, sr=sr)
      pitch_mean = pitches.mean()
      non_silent_frames = np.count_nonzero(librosa.effects.split(y, top_db=20))
      speech_duration = librosa.get_duration(y=y, sr=sr)
      speaking_rate = non_silent_frames / speech_duration * 60
      meter = pyln.Meter(sr)
      loudness = meter.integrated_loudness(y)
      return np.array([pitch_mean, speaking_rate, loudness])
  
  audio_file = ('./speechsample/extreduce1.wav')
  
  
  # Extract features from the audio
  features = extract_features(audio_file)
  
  # Load the SVM model
  loaded_model = pickle.load(open('./algorithms/svm_model.sav', 'rb'))
  
  # Reshape the input data
  input_data_reshaped = features.reshape(1, -1)
  
  # Use the model to predict the label for the extracted features
  predicted_label = loaded_model.predict(input_data_reshaped)
  
  # Map the predicted label to 'introvert' or 'extrovert'
  label = 'extrovert' if predicted_label == 0 else 'introvert'
  
  #  Print the predicted label
  print(label)

</py-script>


</body>
</html>